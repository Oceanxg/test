module async_fifo #(
    parameter integer DATA_WIDTH = 256,
    parameter integer ADDR_WIDTH = 4
) (
    input  wire                    wr_clk,
    input  wire                    rd_clk,
    input  wire                    rst_n,
    input  wire                    wr_en,
    input  wire                    rd_en,
    input  wire [DATA_WIDTH-1:0]   din,
    output reg  [DATA_WIDTH-1:0]   dout,
    output wire                    full,
    output wire                    empty
);

localparam integer DEPTH = (1 << ADDR_WIDTH);

reg [DATA_WIDTH-1:0] mem [0:DEPTH-1];

reg [ADDR_WIDTH:0] wr_bin;
reg [ADDR_WIDTH:0] rd_bin;
reg [ADDR_WIDTH:0] wr_gray;
reg [ADDR_WIDTH:0] rd_gray;

reg [ADDR_WIDTH:0] rd_gray_sync1;
reg [ADDR_WIDTH:0] rd_gray_sync2;
reg [ADDR_WIDTH:0] wr_gray_sync1;
reg [ADDR_WIDTH:0] wr_gray_sync2;

wire [ADDR_WIDTH:0] wr_bin_next;
wire [ADDR_WIDTH:0] rd_bin_next;
wire [ADDR_WIDTH:0] wr_gray_next;
wire [ADDR_WIDTH:0] rd_gray_next;

wire wr_allow;
wire rd_allow;

assign wr_allow = wr_en && !full;
assign rd_allow = rd_en && !empty;

assign wr_bin_next  = wr_bin + wr_allow;
assign rd_bin_next  = rd_bin + rd_allow;
assign wr_gray_next = (wr_bin_next >> 1) ^ wr_bin_next;
assign rd_gray_next = (rd_bin_next >> 1) ^ rd_bin_next;

// 写时钟域：写入 RAM，更新写指针
always @(posedge wr_clk or negedge rst_n) begin
    if (!rst_n) begin
        wr_bin  <= { (ADDR_WIDTH+1){1'b0} };
        wr_gray <= { (ADDR_WIDTH+1){1'b0} };
    end else begin
        if (wr_allow) begin
            mem[wr_bin[ADDR_WIDTH-1:0]] <= din;
        end
        wr_bin  <= wr_bin_next;
        wr_gray <= wr_gray_next;
    end
end

// 读时钟域：读取 RAM，更新读指针
always @(posedge rd_clk or negedge rst_n) begin
    if (!rst_n) begin
        rd_bin  <= { (ADDR_WIDTH+1){1'b0} };
        rd_gray <= { (ADDR_WIDTH+1){1'b0} };
        dout    <= { DATA_WIDTH{1'b0} };
    end else begin
        if (rd_allow) begin
            dout <= mem[rd_bin[ADDR_WIDTH-1:0]];
        end
        rd_bin  <= rd_bin_next;
        rd_gray <= rd_gray_next;
    end
end

// 将读指针同步到写时钟域
always @(posedge wr_clk or negedge rst_n) begin
    if (!rst_n) begin
        rd_gray_sync1 <= { (ADDR_WIDTH+1){1'b0} };
        rd_gray_sync2 <= { (ADDR_WIDTH+1){1'b0} };
    end else begin
        rd_gray_sync1 <= rd_gray;
        rd_gray_sync2 <= rd_gray_sync1;
    end
end

// 将写指针同步到读时钟域
always @(posedge rd_clk or negedge rst_n) begin
    if (!rst_n) begin
        wr_gray_sync1 <= { (ADDR_WIDTH+1){1'b0} };
        wr_gray_sync2 <= { (ADDR_WIDTH+1){1'b0} };
    end else begin
        wr_gray_sync1 <= wr_gray;
        wr_gray_sync2 <= wr_gray_sync1;
    end
end

// FIFO 满：写指针下一拍 Gray 码等于“读指针 Gray 码高两位取反”
assign full = (wr_gray_next == {~rd_gray_sync2[ADDR_WIDTH:ADDR_WIDTH-1], rd_gray_sync2[ADDR_WIDTH-2:0]});

// FIFO 空：读指针下一拍 Gray 码等于同步后的写指针 Gray 码
assign empty = (rd_gray_next == wr_gray_sync2);

endmodule
